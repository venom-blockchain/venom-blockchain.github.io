"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[1236],{4137:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(t),m=a,f=p["".concat(l,".").concat(m)]||p[m]||u[m]||i;return t?o.createElement(f,r(r({ref:n},d),{},{components:t})):o.createElement(f,r({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7531:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=t(7462),a=(t(7294),t(4137));const i={sidebar_position:0,sidebar_label:"Simple NFT auction",description:"This guide shows you how you can perform on-chain interaction with previously deployed TIP-4 token"},r="Venom In Action. Simple NFT auction",s={unversionedId:"build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/simple-nft-auction",id:"build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/simple-nft-auction",title:"Venom In Action. Simple NFT auction",description:"This guide shows you how you can perform on-chain interaction with previously deployed TIP-4 token",source:"@site/docs/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/simple-nft-auction.md",sourceDirName:"build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action",slug:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/simple-nft-auction",permalink:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/simple-nft-auction",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"Simple NFT auction",description:"This guide shows you how you can perform on-chain interaction with previously deployed TIP-4 token"},sidebar:"buildSidebar",previous:{title:"Quick start developing with TIP-4",permalink:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/quick-start-developing-with-tip-4"},next:{title:"Frontend for NFT collection",permalink:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/venom-in-action/frontend-for-nft-collection"}},l={},c=[],d={toc:c};function u(e){let{components:n,...i}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"venom-in-action-simple-nft-auction"},"Venom In Action. Simple NFT auction"),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"During the following of this guide's code-listings you can meet keywords like ",(0,a.kt)("inlineCode",{parentName:"p"},"pragma ever-solidity")," or keyword ",(0,a.kt)("inlineCode",{parentName:"p"},"ever")," as a unit of the transfer value. It will be changed to ",(0,a.kt)("inlineCode",{parentName:"p"},"venom")," soon. Follow the news and updates.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"This guide will be more complicated as compared with the Tokensale implementation. It's recommended to pass it secondarily.")),(0,a.kt)("p",null,"First of all, as usual, we should set up our development environment with the locklift. For this smart-contracts guideline, you need to include both ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/quick-start-developing-with-tip-3#install-dependencies"},"TIP-3")," and ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/quick-start-developing-with-tip-4#install-dependencies"},"TIP-4")," dependencies, because our Auction will be accepted in TIP-3 tokens. Let's explore some scheme of our contracts interaction and describe it"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Our smart-contracts interaction logic",src:t(8648).Z,width:"681",height:"491"})),(0,a.kt)("p",null,"NFT creation is a green arrow flow, and auction bids are yellow. Let's describe a processes"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"User mints its own NFT via Collection contract"),(0,a.kt)("li",{parentName:"ol"},"Then, the user deploys an Auction"),(0,a.kt)("li",{parentName:"ol"},"Auction deploys its own TIP-3 TokenWallet via the given TokenRoot address (a familiar mechanic for you from TIP-3 Tokensale guide)"),(0,a.kt)("li",{parentName:"ol"},"The user sends minted NFT to Auction, which implements ",(0,a.kt)("inlineCode",{parentName:"li"},"INftTransfer")," interface and accepts this NFT"),(0,a.kt)("li",{parentName:"ol"},"Another users sends TIP-3 tokens (bid) to Auction with ",(0,a.kt)("inlineCode",{parentName:"li"},"notify = true")," parameter (see TIP-3 specs or TIP-3 guide)"),(0,a.kt)("li",{parentName:"ol"},"Auction's TokenWallet sends a callback to Auction, which handles TIP-3 transfer - checks if the incoming bid amount is more than the previous bid, and updates a leader bid address"),(0,a.kt)("li",{parentName:"ol"},"When time is over, ",(0,a.kt)("inlineCode",{parentName:"li"},"finishAuction")," function will send NFT to the auction winner or old owner, if there are no bids were accepted")),(0,a.kt)("p",null,"That's all! As you can see, the main mechanic of our interaction is callbacks. Let's start implementing our contracts. First, implement Collection and NFT contracts same as in TIP-4 ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/quick-start-developing-with-tip-4"},"quick start")," guide."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Collection.tsol" showLineNumbers',title:'"Collection.tsol"',showLineNumbers:!0},"pragma ever-solidity >= 0.62.0;\n\npragma AbiHeader expire;\npragma AbiHeader time;\npragma AbiHeader pubkey;\n\n\nimport '@broxus/tip4/contracts/TIP4_2/TIP4_2Collection.tsol';\nimport '@broxus/tip4/contracts/TIP4_3/TIP4_3Collection.tsol';\nimport './Nft.tsol';\n\ncontract Collection is TIP4_2Collection, TIP4_3Collection {\n\n    /**\n    * Errors\n    **/\n    uint8 constant sender_is_not_owner = 101;\n    uint8 constant value_is_less_than_required = 102;\n\n    /// _remainOnNft - the number of crystals that will remain after the entire mint \n    /// process is completed on the Nft contract\n    uint128 _remainOnNft = 0.3 ton;\n\n    constructor(\n        TvmCell codeNft,\n        string json,\n        TvmCell codeIndex,\n        TvmCell codeIndexBasis\n    ) TIP4_1Collection (\n        codeNft\n    ) TIP4_2Collection (\n        json\n    ) TIP4_3Collection (\n        codeIndex,\n        codeIndexBasis\n    ) \n    public {\n        tvm.accept();\n    }\n\n    function mintNft(\n        string json\n    ) external virtual {\n        require(msg.value > _remainOnNft + 0.1 ton, value_is_less_than_required);\n        tvm.rawReserve(0, 4);\n\n        uint256 id = uint256(_totalSupply);\n        _totalSupply++;\n\n        TvmCell codeNft = _buildNftCode(address(this));\n        TvmCell stateNft = _buildNftState(codeNft, id);\n\n        address nftAddr = new Nft{\n            stateInit: stateNft,\n            value: 0,\n            flag: 128\n        }(\n            msg.sender,\n            msg.sender,\n            _remainOnNft,\n            json,\n            _codeIndex,\n            _indexDeployValue,\n            _indexDestroyValue\n        ); \n\n        emit NftCreated(\n            id, \n            nftAddr,\n            msg.sender,\n            msg.sender, \n            msg.sender\n        );\n    \n    }\n\n    function _buildNftState(TvmCell code, uint256 id)\n        internal\n        pure\n        virtual\n        override (TIP4_2Collection, TIP4_3Collection)\n        returns (TvmCell)\n    {\n        return tvm.buildStateInit({contr: Nft, varInit: {_id: id}, code: code});\n    }\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="NFT.tsol" showLineNumbers',title:'"NFT.tsol"',showLineNumbers:!0},"pragma ever-solidity >= 0.62.0;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport '@broxus/tip4/contracts/TIP4_1/TIP4_1Nft.tsol';\nimport '@broxus/tip4/contracts/TIP4_2/TIP4_2Nft.tsol';\nimport '@broxus/tip4/contracts/TIP4_3/TIP4_3Nft.tsol';\n\n\ncontract Nft is TIP4_1Nft, TIP4_2Nft, TIP4_3Nft {\n\n    constructor(\n        address owner,\n        address sendGasTo,\n        uint128 remainOnNft,\n        string json,\n        TvmCell codeIndex,\n        uint128 indexDeployValue,\n        uint128 indexDestroyValue\n    ) TIP4_1Nft(\n        owner,\n        sendGasTo,\n        remainOnNft\n    ) TIP4_2Nft (\n        json\n    ) TIP4_3Nft (\n        indexDeployValue,\n        indexDestroyValue,\n        codeIndex\n    ) \n    public {\n        \n    }\n\n    function _beforeTransfer(\n        address to, \n        address sendGasTo, \n        mapping(address => CallbackParams) callbacks\n    ) internal virtual override(TIP4_1Nft, TIP4_3Nft) {\n        TIP4_3Nft._destructIndex(sendGasTo);\n    }\n\n    function _afterTransfer(\n        address to, \n        address sendGasTo, \n        mapping(address => CallbackParams) callbacks\n    ) internal virtual override(TIP4_1Nft, TIP4_3Nft) {\n        TIP4_3Nft._deployIndex();\n    }\n\n    function _beforeChangeOwner(\n        address oldOwner, \n        address newOwner,\n        address sendGasTo, \n        mapping(address => CallbackParams) callbacks\n    ) internal virtual override(TIP4_1Nft, TIP4_3Nft) {\n        TIP4_3Nft._destructIndex(sendGasTo);\n    }   \n\n    function _afterChangeOwner(\n        address oldOwner, \n        address newOwner,\n        address sendGasTo, \n        mapping(address => CallbackParams) callbacks\n    ) internal virtual override(TIP4_1Nft, TIP4_3Nft) {\n        TIP4_3Nft._deployIndex();\n    }\n}\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"We won't explain this code blocks because it's already done in TIP-4 ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/quick-start-developing-with-tip-4"},"quick start"))),(0,a.kt)("p",null,"Then, let's deal with ",(0,a.kt)("inlineCode",{parentName:"p"},"Auction")," contract. We'll get started from the state and constructor, as usual. Do not forget to add the interfaces we need."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'code title="Auction.tsol" showLineNumbers',code:!0,title:'"Auction.tsol"',showLineNumbers:!0},'pragma ever-solidity >= 0.62.0;\n\npragma AbiHeader expire;\npragma AbiHeader time;\npragma AbiHeader pubkey;\n\n// Interfaces we needs\n// This interface for transferring NFT to winner\nimport "@broxus/tip4/contracts/TIP4_1/interfaces/ITIP4_1NFT.tsol";\n// This interface to accept NFT from owner\nimport "@broxus/tip4/contracts/TIP4_1/interfaces/INftTransfer.tsol";\n// This interface for implementing tip-3 tokens receiving callback\nimport "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";\n// This interface for deploying TokenWallet\nimport "@broxus/tip3/contracts/interfaces/ITokenRoot.tsol";\n// This interface to return lower bids\nimport "@broxus/tip3/contracts/interfaces/ITokenWallet.tsol";\n\n\ncontract Auction is INftTransfer, IAcceptTokensTransferCallback {\n    \n    uint256 static _nonce; // random nonce for affecting on address\n    address static _owner; // owner of auction and nft\n\n    uint32  public _startTime; // auction start time timestmp in seconds\n    uint32  public _endTime; // auction end time timestamp in seconds\n\n    address public _nft; // nft which will be sell\n    \n    uint128 public _currentBid; // state for holding current max bid\n    address public _currentWinner; // current max bid owner\n\n    address public _tokenRoot; // this token we will receive for bids\n    address public _tokenWallet; // wallet for receive bids\n\n    bool public _nftReceived; // is auction already receive nft\n    bool public _closed; // action end flag\n\n    constructor(\n        uint32 startTime,\n        uint32 endTime,\n        address tokenRoot,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept();\n        tvm.rawReserve(0.2 ever, 0);\n        \n        _nftReceived = false;\n        _closed = false;\n\n        _startTime = startTime;\n        _endTime = endTime;\n\n        _tokenRoot = tokenRoot;\n        // familiar wallet deploying mechanic\n        ITokenRoot(_tokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Auction.onTokenWallet\n        } (\n            address(this),\n            0.1 ever\n        );\n        // memento gas management :)\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n}\n')),(0,a.kt)("p",null,"Remember about gas management and token wallet deploying mechanics from the previous Venom In Action ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/simple-tokensale"},"guide"),". Implement ",(0,a.kt)("inlineCode",{parentName:"p"},"onTokenWallet")," callback the same way."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Auction.tsol" showLineNumbers',title:'"Auction.tsol"',showLineNumbers:!0},"pragma ever-solidity >= 0.62.0;\n...\ncontract Auction is INftTransfer, IAcceptTokensTransferCallback {\n...\n    function onTokenWallet(address value) external {\n        require (\n            msg.sender.value != 0 &&\n            msg.sender == _tokenRoot,\n            101\n        );\n        tvm.rawReserve(0.2 ever, 0);\n        // just store our auction's wallet address for future interaction\n        _tokenWallet = value;\n        _owner.transfer({ value: 0, flag: 128, bounce: false });\n    }\n...\n}\n")),(0,a.kt)("p",null,"Ok, the next callback we need is ",(0,a.kt)("inlineCode",{parentName:"p"},"onNftTransfer"),", which will be called when the NFT owner sends NFT to the auction address"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Auction.tsol" showLineNumbers',title:'"Auction.tsol"',showLineNumbers:!0},"pragma ever-solidity >= 0.62.0;\n...\ncontract Auction is INftTransfer, IAcceptTokensTransferCallback {\n...\n    function onNftTransfer(\n        uint256, // id,\n        address oldOwner,\n        address, // newOwner,\n        address, // oldManager,\n        address, // newManager,\n        address, // collection,\n        address gasReceiver,\n        TvmCell // payload\n    ) override external {\n        tvm.rawReserve(0.2 ever, 0);\n        if (oldOwner != _owner || _nftReceived) {\n        // we should return an NFT, received from address, differenced from owner we sets in state\n            mapping(address => ITIP4_1NFT.CallbackParams) empty;\n            // just operating with interface\n            ITIP4_1NFT(msg.sender).transfer{\n                value: 0,\n                flag: 128,\n                bounce: false\n            }(\n                oldOwner,\n                gasReceiver,\n                empty\n            );\n        } else {\n            // positive case: we got an NFT for selling!\n            _nft = msg.sender;\n            _nftReceived = true;\n        }\n    }\n...\n}\n")),(0,a.kt)("p",null,"Great! Now we are ready to accept bids. Let's implement another callback ",(0,a.kt)("inlineCode",{parentName:"p"},"onAcceptTokensTransfer"),", that our ",(0,a.kt)("inlineCode",{parentName:"p"},"TokenWallet")," will call any time it got an incoming token transaction. Take attention! This is the main logic of our auction!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Auction.tsol" showLineNumbers',title:'"Auction.tsol"',showLineNumbers:!0},"pragma ever-solidity >= 0.62.0;\n...\ncontract Auction is INftTransfer, IAcceptTokensTransferCallback {\n...\n    function onAcceptTokensTransfer(\n        address, // tokenRoot,\n        uint128 amount,\n        address sender,\n        address, // senderWallet,\n        address remainingGasTo,\n        TvmCell payload\n    ) override external {\n        require (msg.sender.value != 0 && msg.sender == _tokenWallet, 101);\n        tvm.rawReserve(0.2 ever, 0);\n        // check bid correctness:\n        // * _nftReceived shoul be true (if not, it means that owner didn't send NFT yet)\n        // * now must be between start and end\n        // * received bid amount must be more than previous bid amount\n        if (\n            _nftReceived      &&\n            now >= _startTime &&\n            now <= _endTime   &&\n            amount > _currentBid\n        ) {\n            // bid updating\n            uint128 oldBit = _currentBid;\n            address oldWinner = _currentWinner;\n            _currentBid = amount;\n            _currentWinner = sender;\n            if (oldBit > 0) {\n                // returning previous bid\n                TvmCell empty;\n                // REMEMBER that msg.sender is our TokenWallet! So we just call them to transfer back\n                ITokenWallet(msg.sender).transfer{value: 0, flag: 128}(\n                    oldBit,\n                    oldWinner,\n                    0,\n                    remainingGasTo,\n                    true,\n                    empty\n                );\n            }\n        } else {\n            // if bid wasn't correct - we return it to sender\n            // REMEMBER that msg.sender is our TokenWallet! So we just call them to transfer back\n            ITokenWallet(msg.sender).transfer{value: 0, flag: 128}(\n                amount,\n                sender,\n                0,\n                remainingGasTo,\n                true,\n                payload\n            );\n        }\n    }\n...\n}\n")),(0,a.kt)("p",null,"That's it. How hard is that? The last thing we need - is ",(0,a.kt)("inlineCode",{parentName:"p"},"finishAuction")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Auction.tsol" showLineNumbers',title:'"Auction.tsol"',showLineNumbers:!0},"pragma ever-solidity >= 0.62.0;\n...\ncontract Auction is INftTransfer, IAcceptTokensTransferCallback {\n...\n    // anyone can call this function!\n    // so owner has no way to cheat\n    function finishAuction(\n        address sendRemainingGasTo\n    ) public {\n        // it can be finished only after endTime we set\n        require(now >= _endTime, 102);\n        require(msg.value >= 1 ever, 103);\n        // remember about gas management...and about gas constants libraries too :)\n        tvm.rawReserve(0.2 ever, 0);\n        if (_currentBid > 0) {\n            // bid more than zero, so somebody has won! let's send NFT to winner\n            _closed = true;\n            mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;\n            TvmCell empty;\n            ITIP4_1NFT(_nft).transfer{\n                value: 0.1 ever,\n                flag: 1,\n                bounce: false\n            }(\n                _currentWinner,\n                sendRemainingGasTo,\n                noCallbacks\n            );\n            // do not forget to send bid amount for auction owner!\n            ITokenWallet(_tokenWallet).transfer{value: 0, flag: 128}(\n                _currentBid,\n                _owner,\n                0.1 ever,\n                sendRemainingGasTo,\n                true,\n                empty\n            );\n        } else {\n            _closed = true;\n            // there is no bids, sad :(\n            // returning NFT back to owner...may be next time :(\n            mapping(address => ITIP4_1NFT.CallbackParams) noCallbacks;\n            ITIP4_1NFT(_nft).transfer{\n                value: 0.1 ever,\n                flag: 1,\n                bounce: false\n            }(\n                _owner,\n                sendRemainingGasTo,\n                noCallbacks\n            );\n        }\n    }\n...\n}\n")),(0,a.kt)("p",null,"You can explore this sample (with tests and some scripts) by going to this ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/nft-auction-contracts"},"repository"),". But we should talk about scripts we need because this sample needs not only deploy scripts. Moving on."),(0,a.kt)("p",null,"We can take collection deploying script and NFT minting scripts from ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/how-to-create-your-own-non-fungible-tip-4-token/quick-start-developing-with-tip-4#deploy-action"},"TIP-4 quick start"),". Script for auction deploying is not really hard too."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="3-deploy-auction.ts" showLineNumbers',title:'"3-deploy-auction.ts"',showLineNumbers:!0},'import { Address, getRandomNonce, WalletTypes } from "locklift";\n\n// you can pass this parameter by cli or get them by some file reading for example or calculate an address with locklift.provider.getExpectedAddress()\n// we just hardcode it here\nconst TOKEN_ROOT_ADDRESS = new Address("0:72150b21cc717202dedfb787068970e9d78b6a7e15447f3c1695420768f9aafb")\n\nasync function main() {\n    const signer = (await locklift.keystore.getSigner("0"))!;\n    // creating new account for Collection calling (or you can get already deployed by locklift.factory.accounts.addExistingAccount)\n    const someAccount = await locklift.factory.accounts.addExistingAccount({\n        type: WalletTypes.WalletV3,\n        publicKey: signer.publicKey\n    });\n    const { contract: sample, tx } = await locklift.factory.deployContract({\n        contract: "Auction",\n        publicKey: signer.publicKey,\n        initParams: {\n            _owner: someAccount.address,\n            _nonce: getRandomNonce()\n        },\n        constructorParams: {\n            startTime: Math.floor(Date.now() / 1000) + 3600, // just for example. Of course you should put timestamp you want (in seconds)\n            endTime: Math.floor(Date.now() / 1000) + 14400,\n            tokenRoot: TOKEN_ROOT_ADDRESS,\n            sendRemainingGasTo: someAccount.address\n        },\n        value: locklift.utils.toNano(5),\n    });\n  \n    console.log(`Auction deployed at: ${sample.address.toString()}`);\n}\n  \nmain()\n    .then(() => process.exit(0))\n    .catch(e => {\n        console.log(e);\n        process.exit(1);\n    });\n')),(0,a.kt)("p",null,"The next script, that can be useful for you - sending NFT to Auction. Let's code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="" showLineNumbers',title:'""',showLineNumbers:!0},'import { Address, toNano, WalletTypes } from "locklift";\n\n// you can pass this parameters by cli or get them by some file reading for example or calculate an address with locklift.provider.getExpectedAddress()\n// we just hardcode it here\nconst NFT_ADDRESS = new Address("0:304150265fbbe8680759cb7ec98cfa598b8a109396338b2916de1684a36a7679")\nconst AUCTION_ADDRESS = new Address("0:94ebb201aa8e3d436fe1d1a9ecd80dbd46b44c11567cc69cbc11f8295f98dd32")\n\nasync function main() {\n    const signer = (await locklift.keystore.getSigner("0"))!;\n    // creating new account for Collection calling (or you can get already deployed by locklift.factory.accounts.addExistingAccount)\n    const someAccount = await locklift.factory.accounts.addExistingAccount({\n        type: WalletTypes.WalletV3,\n        publicKey: signer.publicKey\n    });\n    // instantiate NFT contract\n    const nftInstance = await locklift.factory.getDeployedContract(\n        "NFT",\n        NFT_ADDRESS\n    )\n    // and call a transfer method to auction from owner\n    await nftInstance.methods.transfer({\n        to: AUCTION_ADDRESS,\n        sendGasTo: someAccount.address,\n        // attention! Next field is important for calling our onNftTransfer callback!\n        // you may lose your NFT if you don\'t set up callback for auction here!\n        callbacks: [[AUCTION_ADDRESS, {value: toNano(0.1), payload: ""}]] \n    }).send({\n        from: someAccount.address,\n        amount: toNano(2)\n    })\n  \n    console.log(`NFT has been sent`);\n}\n  \nmain()\n    .then(() => process.exit(0))\n    .catch(e => {\n        console.log(e);\n        process.exit(1);\n    });\n')),(0,a.kt)("p",null,"Pay attention to ",(0,a.kt)("inlineCode",{parentName:"p"},"callback")," parameter of NFT's ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer")," method"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'callbacks: [[AUCTION_ADDRESS, {value: toNano(0.1), payload: ""}]] \n')),(0,a.kt)("p",null,"This is a really important step. You may lose your NFT if don't specify a callback for our auction, because a callback ",(0,a.kt)("inlineCode",{parentName:"p"},"onNftTransfer")," won't be called. The same idea should be used by your auction participants. They should send TIP-3 tokens to Auction with ",(0,a.kt)("inlineCode",{parentName:"p"},"notify: true")," parameter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'await tokenWalletInstance.methods.transfer({\n        amount: 1000000000, // with decimals\n        recipient: AUCTION_ADDRESS, // because it got it\'s own wallet\n        deployWalletValue: 0, // we know, that auction wallet deployed already\n        remainingGasTo: someAccount.address,\n        notify: true, // IMPORTANT to set it "true" for onAcceptTokensTransfer to be called \n        payload: ""\n}).send({\n    from: someAccount.address,\n    amount: toNano(2)\n})\n')),(0,a.kt)("p",null,"All you need now is a write some tests with locklift supports. This all-in-one example with locklift environment, some simple tests and deploy scripts is available in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/nft-auction-contracts"},"repo"),"."))}u.isMDXComponent=!0},8648:(e,n,t)=>{t.d(n,{Z:()=>o});const o=t.p+"assets/images/auction-cab354d7d6d606556e852a500db57e04.svg"}}]);