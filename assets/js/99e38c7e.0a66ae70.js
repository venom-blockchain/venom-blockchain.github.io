"use strict";(self.webpackChunkve_ps=self.webpackChunkve_ps||[]).push([[3717],{4137:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=o.createContext({}),u=function(e){var n=o.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=u(e.components);return o.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},c=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(t),m=a,k=c["".concat(i,".").concat(m)]||c[m]||p[m]||r;return t?o.createElement(k,l(l({ref:n},d),{},{components:t})):o.createElement(k,l({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=c;var s={};for(var i in n)hasOwnProperty.call(n,i)&&(s[i]=n[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var u=2;u<r;u++)l[u]=t[u];return o.createElement.apply(null,l)}return o.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9483:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var o=t(7462),a=(t(7294),t(4137));const r={sidebar_position:0,sidebar_label:"Simple Tokensale",description:"This guide shows you how you can perform on-chain interaction with previously deployed TIP-3 token"},l="Venom In Action. Simple Tokensale",s={unversionedId:"build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/simple-tokensale",id:"build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/simple-tokensale",title:"Venom In Action. Simple Tokensale",description:"This guide shows you how you can perform on-chain interaction with previously deployed TIP-3 token",source:"@site/docs/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/simple-tokensale.md",sourceDirName:"build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action",slug:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/simple-tokensale",permalink:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/simple-tokensale",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"Simple Tokensale",description:"This guide shows you how you can perform on-chain interaction with previously deployed TIP-3 token"},sidebar:"buildSidebar",previous:{title:"Quick start developing with TIP-3",permalink:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/quick-start-developing-with-tip-3"},next:{title:"Extend our Tokensale with frontend",permalink:"/build/development-guides/how-to-create-your-own-fungible-tip-3-token/venom-in-action/extend-our-tokensale-with-frontend"}},i={},u=[],d={toc:u};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"venom-in-action-simple-tokensale"},"Venom In Action. Simple Tokensale"),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"During the following of this guide's code-listings you can meet keywords like ",(0,a.kt)("inlineCode",{parentName:"p"},"pragma ever-solidity")," or keyword ",(0,a.kt)("inlineCode",{parentName:"p"},"ever")," as a unit of the transfer value. It will be changed to ",(0,a.kt)("inlineCode",{parentName:"p"},"venom")," soon. Follow the news and updates.")),(0,a.kt)("p",null,"Who needs a token, that nobody can buy? So, let's create your first tokensale contract!"),(0,a.kt)("p",null,"Perhaps, you already can set up your venom developer environment. If not - follow ",(0,a.kt)("a",{parentName:"p",href:"/build/development-guides/setting-up-the-venom-smart-contract-development-environment"},"this")," guide. If you are already familiar with this action - let's start with locklift init."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npx locklift init --path my-first-crowdsale\n")),(0,a.kt)("p",null,"As in a previous guide, we need to add TIP-3 contracts as a dependency to this project:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npm i --save-dev @broxus/tip3\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="locklift.config.ts" showLineNumbers',title:'"locklift.config.ts"',showLineNumbers:!0},'compiler: {\n    ...\n    externalContracts: {\n      "node_modules/@broxus/tip3/build": ["TokenRoot", "TokenWallet"],\n    },\n  }\n')),(0,a.kt)("p",null,"Now we can start with our tokensale contract. Create a ",(0,a.kt)("inlineCode",{parentName:"p"},"Tokensale.tsol")," file in your ",(0,a.kt)("inlineCode",{parentName:"p"},"contracts")," folder. First of all, let's arrange pragmas and imports."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.tsol" showLineNumbers',title:'"Tokensale.tsol"',showLineNumbers:!0},'pragma ever-solidity >= 0.62.0;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";\nimport "@broxus/tip3/contracts/interfaces/ITokenRoot.tsol";\nimport "@broxus/tip3/contracts/interfaces/ITokenWallet.tsol";\n')),(0,a.kt)("p",null,"As you can see, we will use some interfaces from the TIP-3 implementation. Let's define our contract state and constructor."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.tsol" showLineNumbers',title:'"Tokensale.tsol"',showLineNumbers:!0},"contract Tokensale {\n    uint16  static _nonce; // Some random value to affect on contract address\n    address static _owner; // Tokensale owner. Will receive all transfers\n\n    address public _distributedTokenRoot; // TIP3 TokenRoot address for deploying wallet for Tokensale. This token will be distributed\n    address public _distributedTokenWallet; // TIP3 wallet for Tokensale for sending purchased tokens\n    uint256 public _supply; // How much tokens will be distributed (with decimals)\n    uint128 public _rate; // How much tokens buyer will receive for 1 nanovenom (1*10^9)\n\n    constructor(\n        address distributedTokenRoot,\n        uint256 supply,\n        uint128 rate,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept(); // This action is required to process external messages that bring no value - deploy as we have.\n        tvm.rawReserve(1 ever, 0); // we will always reserve 1 venom on this contract\n        _distributedTokenRoot = distributedTokenRoot;\n        _rate = rate;\n        _supply = supply;\n\n        // fundamental mechanic of dapps working with tip3 - deploy it's own wallet to operate with. check tip3 specs for more info\n        ITokenRoot(distributedTokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Tokensale.onTokenWallet // this callback will be called by TokenRoot after deploying wallet for tokensale\n        } (\n            address(this),\n            0.1 ever\n        );\n        // sending remaining gas after setups\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n}\n")),(0,a.kt)("p",null,"So, let's break down some fundamental mechanics in this small piece of code. The very first thing that you should look out - gas management. Look at these two lines:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"tvm.rawReserve(1 ever, 0);\nsendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n")),(0,a.kt)("p",null,"Fist code line is like a reservation of 1 venom on this contract. Essentially it generates an outbound message carrying ",(0,a.kt)("strong",{parentName:"p"},"reserve")," nanovenoms to oneself so that the next performed actions would not be able to spend more venoms than the remainder."),(0,a.kt)("p",null,"The next line is a best practice for gas management in Venom. You always should send the remaining gas to the message sender or another given address. Pay attention to ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"flag")," parameters of ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer")," function. Flag 128 means, that this transfer will carry all remaining not reserver gas! Summarizing, we have a flow like this:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Reserving some initial contract balance for always active state."),(0,a.kt)("li",{parentName:"ol"},"Perform contract logic (may be checked inbound value if you need this)"),(0,a.kt)("li",{parentName:"ol"},"Send remaining gas with 128 flag to message sender or another pointed address")),(0,a.kt)("p",null,"The next important logic of our constructor code is deploying a wallet for contract on-chain"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.tsol" showLineNumbers',title:'"Tokensale.tsol"',showLineNumbers:!0},"...\n        ITokenRoot(distributedTokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Tokensale.onTokenWallet // this callback will be called by TokenRoot after deploying wallet for tokensale\n        } (\n            address(this),\n            0.1 ever\n        );\n...\n")),(0,a.kt)("p",null,"This action generates an outbound message to ",(0,a.kt)("inlineCode",{parentName:"p"},"TokenRoot")," contract by calling a ",(0,a.kt)("inlineCode",{parentName:"p"},"deployWallet")," function. This function is ",(0,a.kt)("inlineCode",{parentName:"p"},"responsible")," . That means it will generate an internal outbound message by calling a function, that was passed in a ",(0,a.kt)("inlineCode",{parentName:"p"},"callback")," parameter (",(0,a.kt)("inlineCode",{parentName:"p"},"onTokenWallet")," in our case). Let's implement this function for our ",(0,a.kt)("inlineCode",{parentName:"p"},"Tokensale")," contract. From TIP-3 source code we know, that ",(0,a.kt)("inlineCode",{parentName:"p"},"deployWallet")," returns tonly one parameter - deployed wallet address. So, just store it in our state."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.tsol" showLineNumbers',title:'"Tokensale.tsol"',showLineNumbers:!0},"...\n    function onTokenWallet(address value) external {\n        require (\n            msg.sender.value != 0 &&\n            msg.sender == _distributedTokenRoot, // check, that calling was from TokenRoot we need\n            101 // some error code for this require\n        );\n        tvm.rawReserve(1 ever, 0);\n        _distributedTokenWallet = value; // store deployed tip3 wallet address\n        _owner.transfer({ value: 0, flag: 128, bounce: false }); // sending remaining gas after setups\n    }\n...\n")),(0,a.kt)("p",null,"That's all. Now, when we will deploy ",(0,a.kt)("inlineCode",{parentName:"p"},"Tokensale")," contract, ",(0,a.kt)("inlineCode",{parentName:"p"},"deployWallet")," will be called too and returned value will be stored in our contract state. All we need is a function to sell our tokens."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.tsol" showLineNumbers',title:'"Tokensale.tsol"',showLineNumbers:!0},"...\n    function buyTokens(uint128 deposit) external view {\n        tvm.rawReserve(1 ever, 0);\n        // 1 venom is a technical value for fee...remaining gas will be returned after tokens transfer (from tip3 wallet)\n        if (deposit > msg.value + 1 ever) { // if we using require, we are frozing incoming value in this contract, so just return it \n            msg.sender.transfer({ value: 0, flag: 128, bounce: false });\n        } else {\n            uint128 purchase = _rate * deposit;\n            if (purchase > _supply) {\n                msg.sender.transfer({ value: 0, flag: 128, bounce: false});\n            } else {\n                TvmCell empty;\n                // here we just operate with deployed in constructor wallet. owner should provide token supply on this wallet before sales!\n                ITokenWallet(_distributedTokenWallet).transfer{ value: 0, flag: 128 }(\n                    purchase,\n                    msg.sender,\n                    0.1 ever, // this parameter allows to deploy wallet for user, if it's not deployed yet. (fee takes from message so will be payed by user)\n                    msg.sender,\n                    false,\n                    empty\n                );\n            }\n        }\n    }\n...\n")),(0,a.kt)("p",null,"Notice, that we don't use ",(0,a.kt)("inlineCode",{parentName:"p"},"require")," instruction to check incoming value. If we will use ",(0,a.kt)("inlineCode",{parentName:"p"},"require"),", the user's deposit will not be returned to the sender and will stay on contract. So anyone can take this as a remaining gas, according to gas management (because these venoms won't be reserved). Best practice - when you check something incoming (venoms, other tip-3 tokens), you should use ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"require"),"."),(0,a.kt)("p",null,"The next mechanic is already familiar to you. Tokensale just calls its own deployed in the constructor wallet to transfer tokens for a buyer. Of course, you should transfer supply tokens to tokensale wallet before sales starts :)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"ITokenWallet(_distributedTokenWallet).transfer{ value: 0, flag: 128 }(\n    purchase,\n    msg.sender,\n    0.1 ever, // this parameter allows to deploy wallet for user, if it's not deployed yet. (fee takes from message so will be payed by user)\n    msg.sender,\n    false,\n    empty\n);\n")),(0,a.kt)("p",null,"Pay attention to ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"flag"),". Again 0 and 128. This allows us to delegate sending of the remaining gas to TokenWallet contract (of course if you are sure, that delegate performs this action). We send all remaining not reserved gas to TokenWallet, and, after its own actions, TokenWallet will return the remaining gas where required. (4th parameter of transfer function)."),(0,a.kt)("p",null,"So, let's check our final contract code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity",metastring:'title="Tokensale.tsol" showLineNumbers',title:'"Tokensale.tsol"',showLineNumbers:!0},'pragma ever-solidity >= 0.62.0;\npragma AbiHeader expire;\npragma AbiHeader pubkey;\n\nimport "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";\nimport "@broxus/tip3/contracts/interfaces/ITokenRoot.tsol";\nimport "@broxus/tip3/contracts/interfaces/ITokenWallet.tsol";\n\n\ncontract Tokensale {\n    uint16  static _nonce; // some random value to affect on contract address\n    address static _owner; // tokensale owner. will receive all transfers\n\n    address public _distributedTokenRoot; // TIP3 TokenRoot address for deploying wallet for Tokensale. This token will be distributed\n    address public _distributedTokenWallet; // TIP3 wallet for Tokensale for sending purchased tokens\n    uint256 public _supply; // How much tokens will be distributed (with decimals)\n    uint128 public _rate; // How much tokens buyer will receive for 1 nanovenom (1*10^9)\n\n    constructor(\n        address distributedTokenRoot,\n        uint256 supply,\n        uint128 rate,\n        address sendRemainingGasTo\n    ) public {\n        tvm.accept();\n        tvm.rawReserve(1 ever, 0); // we will always reserve 1 venom on this contract\n        _distributedTokenRoot = distributedTokenRoot;\n        _rate = rate;\n        _supply = supply;\n\n        // fundamental mechanic of dapps working with tip3 - deploy it\'s own wallet to operate with. check tip3 specs for more info\n        ITokenRoot(distributedTokenRoot).deployWallet {\n            value: 0.2 ever,\n            flag: 1,\n            callback: Tokensale.onTokenWallet // this callback will be called by TokenRoot after deploying wallet for tokensale\n        } (\n            address(this),\n            0.1 ever\n        );\n        // sending remaining gas after setups\n        sendRemainingGasTo.transfer({ value: 0, flag: 128, bounce: false });\n    }\n\n    function onTokenWallet(address value) external {\n        require (\n            msg.sender.value != 0 &&\n            msg.sender == _distributedTokenRoot,\n            101\n        );\n        tvm.rawReserve(1 ever, 0);\n        _distributedTokenWallet = value; // store deployed tip3 wallet address\n        _owner.transfer({ value: 0, flag: 128, bounce: false }); // sending remaining gas after setups\n    }\n\n    function buyTokens(uint128 deposit) external view {\n        tvm.rawReserve(1 ever, 0);\n        // 1 venom is a technical value for fee...remaining gas will be returned after tokens transfer (from tip3 wallet)\n        if (deposit > msg.value + 1 ever) { // if we using require, we are frozing incoming value in this contract, so just return it \n            msg.sender.transfer({ value: 0, flag: 128, bounce: false });\n        } else {\n            uint128 purchase = _rate * deposit;\n            if (purchase > _supply) {\n                msg.sender.transfer({ value: 0, flag: 128, bounce: false});\n            } else {\n                TvmCell empty;\n                // here we just operate with deployed in constructor wallet. owner should provide token supply on this wallet before sales!\n                ITokenWallet(_distributedTokenWallet).transfer{ value: 0, flag: 128 }(\n                    purchase,\n                    msg.sender,\n                    0.1 ever, // this parameter allows to deploy wallet for user, if it\'s not deployed yet. (fee takes from message so will be payed by user)\n                    msg.sender,\n                    false,\n                    empty\n                );\n            }\n        }\n    }\n}\n')),(0,a.kt)("p",null,"All you need now is a write some tests with locklift supports. This all-in-one example with locklift environment, some simple tests and deploy scripts is available in ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/venom-blockchain/guides/tree/master/tokensale-contracts"},"repo"),"."))}p.isMDXComponent=!0}}]);